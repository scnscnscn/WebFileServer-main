# C++ Web文件服务器技术文档

## 项目概述

这是一个基于C++11实现的Linux下Web文件服务器，采用Reactor事件处理模型，支持文件的上传、下载、删除和列表展示功能。项目展示了现代C++项目的标准架构和开发实践。

## 项目架构

### 整体架构图
```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   浏览器客户端   │────│  HTTP协议通信   │────│   Web服务器     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                                       │
                       ┌───────────────────────────────┼───────────────────────────────┐
                       │                               │                               │
                ┌─────────────┐              ┌─────────────┐              ┌─────────────┐
                │  主线程     │              │  线程池     │              │  文件系统   │
                │ (epoll监听) │              │ (事件处理)  │              │ (文件操作)  │
                └─────────────┘              └─────────────┘              └─────────────┘
```

### 核心设计模式

#### 1. Reactor事件处理模型
- **主线程**：使用epoll进行I/O多路复用，监听所有套接字事件
- **工作线程**：从线程池中获取线程处理具体的业务逻辑
- **统一事件源**：所有I/O事件和信号都通过epoll统一管理

#### 2. 有限状态机
- 请求解析使用状态机模式，按阶段处理HTTP请求
- 响应发送也采用状态机，支持大文件的分块传输

## 目录结构分析

```
WebFileServer/
├── main.cpp                 # 程序入口
├── makefile                 # 构建配置
├── build.sh                 # 构建脚本
├── fileserver/              # 服务器核心模块
│   ├── fileserver.h         # 服务器类声明
│   └── fileserver.cpp       # 服务器类实现
├── threadpool/              # 线程池模块
│   ├── threadpool.h         # 线程池类声明
│   └── threadpool.cpp       # 线程池类实现
├── event/                   # 事件处理模块
│   ├── myevent.h           # 事件类声明
│   └── myevent.cpp         # 事件类实现
├── message/                 # 消息处理模块
│   └── message.h           # HTTP消息类定义
├── utils/                   # 工具函数模块
│   ├── utils.h             # 工具函数声明
│   └── utils.cpp           # 工具函数实现
├── html/                    # 前端页面
│   ├── filelist.html       # 文件列表页面
│   └── fileitem.html       # 文件项模板
└── filedir/                 # 文件存储目录
```

## 核心模块详解

### 1. 服务器核心模块 (fileserver/)

#### WebServer类设计
```cpp
class WebServer {
private:
    int m_listenfd;                    // 监听套接字
    sockaddr_in m_serverAddr;          // 服务器地址
    static int m_epollfd;              // epoll文件描述符
    static bool isStop;                // 服务器停止标志
    static int eventHandlerPipe[2];    // 信号处理管道
    epoll_event resEvents[MAX_RESEVENT_SIZE]; // 事件结果数组
    ThreadPool *threadPool;            // 线程池指针
};
```

#### 关键方法
- `createListenFd()`: 创建并配置监听套接字
- `createEpoll()`: 创建epoll实例
- `epollAddListenFd()`: 将监听套接字加入epoll
- `waitEpoll()`: 主事件循环，监听并分发事件
- `createThreadPool()`: 创建线程池

### 2. 线程池模块 (threadpool/)

#### 设计特点
- **预创建线程**：启动时创建固定数量的工作线程
- **任务队列**：使用std::queue存储待处理事件
- **同步机制**：pthread_mutex_t + sem_t实现线程安全

#### 核心实现
```cpp
class ThreadPool {
private:
    int m_threadNum;                      // 线程数量
    pthread_t *m_threads;                 // 线程数组
    std::queue<EventBase*> m_workQueue;   // 任务队列
    pthread_mutex_t queueLocker;          // 队列互斥锁
    sem_t queueEventNum;                  // 任务计数信号量
};
```

### 3. 事件处理模块 (event/)

#### 事件类层次结构
```cpp
EventBase (基类)
├── AcceptConn    (接受连接事件)
├── HandleRecv    (处理接收事件)
├── HandleSend    (处理发送事件)
└── HandleSig     (处理信号事件)
```

#### 状态管理
- **静态成员**：使用static map保存连接状态
- **状态持久化**：支持非阻塞I/O的断点续传
- **内存管理**：事件处理完成后自动清理

### 4. 消息处理模块 (message/)

#### HTTP消息抽象
```cpp
// 消息状态枚举
enum MSGSTATUS {
    HANDLE_INIT,      // 初始状态
    HANDLE_HEAD,      // 处理消息头
    HANDLE_BODY,      // 处理消息体
    HADNLE_COMPLATE,  // 处理完成
    HANDLE_ERROR      // 处理错误
};

// 基础消息类
class Message {
    MSGSTATUS status;
    std::unordered_map<std::string, std::string> msgHeader;
};

// 请求消息类
class Request : public Message {
    std::string requestMethod;    // GET/POST
    std::string requestResourse;  // 请求资源路径
    std::string httpVersion;      // HTTP版本
    // ... 其他字段
};

// 响应消息类
class Response : public Message {
    std::string responseStatusCode;  // 状态码
    std::string msgBody;            // 响应体
    int fileMsgFd;                  // 文件描述符
    // ... 其他字段
};
```

### 5. 工具函数模块 (utils/)

#### 核心功能
- **日志输出**：`outHead()` 生成带时间戳的日志前缀
- **epoll操作**：封装epoll的增删改操作
- **非阻塞设置**：`setNonBlocking()` 设置文件描述符为非阻塞

## HTTP协议处理

### 请求处理流程
1. **请求行解析**：提取方法、URI、版本
2. **请求头解析**：解析Content-Type、Content-Length等
3. **请求体处理**：
   - GET请求：直接处理
   - POST请求：处理文件上传

### 文件上传处理
```cpp
// multipart/form-data格式解析
if(requestStatus[m_clientFd].msgHeader["Content-Type"] == "multipart/form-data") {
    // 1. 查找boundary边界
    // 2. 解析文件头信息
    // 3. 提取文件名
    // 4. 保存文件内容
    // 5. 检测结束边界
}
```

### 响应生成
- **文件列表**：动态生成HTML页面
- **文件下载**：使用sendfile零拷贝传输
- **重定向**：操作完成后重定向到文件列表

## 性能优化技术

### 1. I/O优化
- **epoll边缘触发**：减少系统调用次数
- **非阻塞I/O**：避免线程阻塞
- **零拷贝传输**：使用sendfile直接传输文件

### 2. 内存管理
- **对象池化**：重用Request/Response对象
- **智能指针**：自动内存管理（可改进点）
- **缓冲区管理**：合理设置读写缓冲区大小

### 3. 并发控制
- **线程池**：避免频繁创建销毁线程
- **EPOLLONESHOT**：确保一个连接同时只被一个线程处理
- **状态保存**：支持请求的分阶段处理

## 开发标准和最佳实践

### 1. 代码组织
- **模块化设计**：按功能划分模块
- **头文件保护**：使用#ifndef防止重复包含
- **命名规范**：
  - 类名：大驼峰命名（WebServer）
  - 成员变量：m_前缀（m_listenfd）
  - 函数名：小驼峰命名（createListenFd）
  - 常量：全大写（MAX_RESEVENT_SIZE）

### 2. 错误处理
- **返回值检查**：所有系统调用都检查返回值
- **错误日志**：使用统一的日志格式
- **资源清理**：确保异常情况下的资源释放

### 3. 内存安全
- **RAII原则**：构造函数获取资源，析构函数释放资源
- **避免内存泄漏**：动态分配的内存及时释放
- **缓冲区安全**：防止缓冲区溢出

### 4. 线程安全
- **互斥锁保护**：共享资源使用互斥锁保护
- **信号量同步**：使用信号量进行线程间同步
- **原子操作**：对简单变量使用原子操作

## 构建系统

### Makefile分析
```makefile
CXX ?= g++

fileserver: main.cpp ./fileserver/fileserver.cpp ./threadpool/threadpool.cpp ./event/myevent.cpp ./utils/utils.cpp
	$(CXX) -std=c++11  $^ -lpthread  -o main

clean:
	rm  -r main
```

#### 关键特性
- **C++11标准**：使用现代C++特性
- **链接库**：链接pthread库支持多线程
- **依赖管理**：明确列出所有源文件依赖

### 构建脚本
```bash
#!/bin/bash
make fileserver
```

## 部署和运行

### 1. 编译
```bash
chmod +x build.sh
./build.sh
```

### 2. 运行
```bash
./main
```

### 3. 访问
在浏览器中访问：`http://服务器IP:8888`

## 扩展建议

### 1. 功能扩展
- [ ] 用户认证系统
- [ ] 文件权限管理
- [ ] 断点续传支持
- [ ] 文件预览功能

### 2. 性能优化
- [ ] 连接池管理
- [ ] 缓存机制
- [ ] 负载均衡
- [ ] 异步日志系统

### 3. 安全加固
- [ ] HTTPS支持
- [ ] 文件类型检查
- [ ] 上传大小限制
- [ ] 防止目录遍历攻击

### 4. 代码质量
- [ ] 单元测试
- [ ] 代码覆盖率
- [ ] 静态代码分析
- [ ] 内存泄漏检测

## 学习要点

### 1. 网络编程
- **套接字编程**：TCP服务器的基本实现
- **I/O多路复用**：epoll的使用方法
- **非阻塞I/O**：提高服务器并发能力

### 2. 多线程编程
- **线程池设计**：预创建线程提高效率
- **线程同步**：互斥锁和信号量的使用
- **线程安全**：共享资源的保护机制

### 3. HTTP协议
- **协议解析**：HTTP请求和响应的格式
- **状态码**：常用HTTP状态码的含义
- **文件上传**：multipart/form-data格式处理

### 4. 系统编程
- **文件操作**：文件的读写和管理
- **信号处理**：优雅关闭服务器
- **内存管理**：避免内存泄漏

### 5. 设计模式
- **Reactor模式**：事件驱动的网络编程模式
- **状态机模式**：协议解析的标准方法
- **工厂模式**：事件对象的创建

## 调试技巧

### 1. 日志分析
- 观察日志输出了解程序执行流程
- 根据错误日志定位问题
- 使用不同日志级别区分信息重要性

### 2. 工具使用
- **gdb**：调试程序崩溃问题
- **valgrind**：检测内存泄漏
- **strace**：跟踪系统调用
- **netstat**：查看网络连接状态

### 3. 性能分析
- **top/htop**：监控CPU和内存使用
- **iotop**：监控磁盘I/O
- **tcpdump**：抓包分析网络通信

## 总结

这个项目展示了一个完整的C++网络服务器的实现，涵盖了网络编程、多线程、HTTP协议处理等多个技术领域。通过学习这个项目，您可以掌握：

1. **现代C++项目的组织结构**
2. **网络服务器的核心架构**
3. **多线程编程的最佳实践**
4. **HTTP协议的实际应用**
5. **系统编程的基本技能**

建议您按照模块逐步学习，先理解整体架构，再深入每个模块的实现细节，最后尝试添加新功能或优化现有代码。